{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Grayhill Touch Encoder Documentation Page Communication Protocol: - ( SAE J1939 ) - USB HID Firmware Update: - Live Update","title":"Home"},{"location":"#grayhill-touch-encoder-documentation-page","text":"Communication Protocol: - ( SAE J1939 ) - USB HID Firmware Update: - Live Update","title":"Grayhill Touch Encoder Documentation Page"},{"location":"live_update/","text":"1. Overview This document describes the live update procedure of the Grayhill Touch Encoder (TE). 1.1 Terminology update source - a file distributed by Grayhill for the purpose of updating the whole or part of the Touch Encoder software. update component - a single unit the Touch Encoder update procedure acts upon in order to install software. It typically corresponds to a software component of the Touch Encoder. We distinguish the following types: Bootloader - a blob used to update the Touch Encoder bootloader. Firmware - a blob used to update the Touch Encoder firmware. Project - an archive containing the Touch Encoder UI project. This update component is also an update source. Package - a container for other update components. This component by nature is also an update source. origin - host machine or other entity on the network/bus initiating the live update process. 2. Update Procedure Overview The following flowchart depicts the update procedure from the perspective of the Touch Encoder. Note : The live update procedure is divided into two stages, Upload Stage (light blue) and Update Stage (light red). Each of the stages is covered in a greater detail in subsequent sections. 2.1 Upload Stage Upload stage starts immediately after the live update has been requested and the positive acknowledgment has been sent to the origin. TE assumes a receiver role, disables all input and blocks all other communication. At this time, TE starts accepting data packets that will together compose the update source . The packets are expected to be sent sequentially in-order to yield correct assembly at the destination. The TE relies on the transport layer to guarantee in-order reception. 2.1.1 Failure conditions Each of the following conditions causes the update procedure to be aborted. At the same time, a Download Status message with appropriate error value is sent to the origin and any following data packets are met with negative acknowledgment. timeout - TE allows up to 1000 ms for each consecutive data packet to arrive, therefore a timeout event is raised if a packet is not seen within this window. overflow - The exact number of bytes is expected to be received. Uploading more bytes than claimed is an error. underflow - Uploading less bytes than the declared amount is a distinct failure condition but the consequence is equivalent to that of a timeout . IO error - Any error that TE encounters when assembling the update source . 2.1.2 Success Condition Occurs when the exact number of bytes have been transferred. The TE emits Download Status with error value of 0 and immediately enters the Update Stage upon successfully completing the Upload Stage . 2.2 Update Stage Following a successful Upload Stage TE will attempt to use the uploaded file as the update source . At this stage the origin assumes the listener role since the TE will periodically send out status messages as the update process advances. One type of status messages in the Update Stage is Component Status . These messages provide feedback about the specific update component currently being installed. Another type in this stage is Update Status . Such messages, if they contain a non-zero status value, are terminal. Both types are briefly discussed in the following sections. 2.2.1 Component Status Message The following briefly describes each variant of a component status message: - Component Progress - reports component completion state as a percent value - Component Busy - component is installing but the progress is indeterminate - Component End - component installation has concluded with a specific status code 2.2.2 Update Status Message As mentioned before, messages of this type mark the end of the update process. The exception to this is the periodically emitted message carrying status value of 0 . In all other cases, the status value is used to determine the overall result of the update process. The meaning of each value is given as follows. -2 - update failed due to an error in the update component . The exact problem can be identified by investigating the last Component End message. -1 - update failed due to an event other than the one captured in status value -2 . 1 - update procedure succeeded and the changes were already applied. 2 - update succeeded but the changes will be applied upon restart. 3 - all corresponding components are up-to-date and no update is necessary. 2.3 Post-update In this stage, there are three possible courses of action. The choice is dependent on the success or failure of the update procedure. Regardless of the course taken, the TE restores all communication. Restart - Upon update status value of 2 , the TE is set to restart after 10 seconds. With the communication enabled, the origin can issue an immediate restart. Fully Operational State - The TE resumes its normal operation as a result of update status value of 3 , the up-to-date result. The same is true in case of a failed upload. Semi-operational State - This state results from a failed Update Stage . The TE remains with disabled input. With the communication restored, it is possible to reattempt the live update procedure. 3. Transport-specific Items 3.1 SAE J1939 Please refer to our SAE J1939 guide in order to learn how to issue the live update request. For reliable data transfer we require the use of J1939 TP, preferably with the largest possible MTU of 1785 bytes (7 * 255). Using a smaller transmission size has the potential of the overhead dominating the payload and negatively affecting the update process duration. Transferring the entire update source using just CAN datagrams is discouraged. It is extremely prone to errors with both source and destination going out of sync. We cannot make any correctness guarantees with this choice of transport. 3.2 HID (COMING SOON) 4. Appendix 4.1 Component Type Values Name Value Package 0 Bootloader 1 Firmware 2 Project 3 4.2 Status Messages 4.2.1 Download Status Start Length Desc. Values 1.1 1 Byte Type 0x01 - Download Status 2.1 1 Byte Error 0 - No Error 1 - Unknown 2 - Timeout 3 - Overflow 4 - IO Error 4.2.2 Update Status Start Length Desc. Values 1.1 1 Byte Type 0x02 - Update Status 2.1 1 Byte Status -2 - Update failure (component failure) -1 - Update failure 0 - Update Ongoing 1 - Update Success 2 - Update Success (restart required) 3 - Update Success (up-to-date) 4.2.3 Component Status Component Busy Start Length Desc. Values 1.1 1 Byte Type 0x03 - Component Status 2.1 1 Byte Component Type Component Type Value 3.1 1 Byte Component Status 0xB1 - Busy 4.1 4 Bytes Padding 0x00000000 Component Progress Start Length Desc. Values 1.1 1 Byte Type 0x03 - Component Status 2.1 1 Byte Component Type Component Type Value 3.1 1 Byte Component Status 0x30 - Progress 4.1 4 Bytes Progress [ 0 .. 100 ] - percent value Component End Start Length Desc. Values 1.1 1 Byte Type 0x03 - Component Status 2.1 1 Byte Component Type Component Type Value 3.1 1 Byte Component Status 0xF1 - End 4.1 4 Bytes Status Code Component Status Code 4.3 Component Status Codes Note : The table below is not comprehensive and contains only the most common codes. Value Description 0x00000000 OK 0x00000001 Up-to-date 0x00010001 Failed opening update source 0x00020001 --- || --- 0x00050001 --- || --- 0x00010002 No project found 0x00020005 File failed validation","title":"Live Update"},{"location":"live_update/#1-overview","text":"This document describes the live update procedure of the Grayhill Touch Encoder (TE).","title":"1. Overview"},{"location":"live_update/#11-terminology","text":"update source - a file distributed by Grayhill for the purpose of updating the whole or part of the Touch Encoder software. update component - a single unit the Touch Encoder update procedure acts upon in order to install software. It typically corresponds to a software component of the Touch Encoder. We distinguish the following types: Bootloader - a blob used to update the Touch Encoder bootloader. Firmware - a blob used to update the Touch Encoder firmware. Project - an archive containing the Touch Encoder UI project. This update component is also an update source. Package - a container for other update components. This component by nature is also an update source. origin - host machine or other entity on the network/bus initiating the live update process.","title":"1.1 Terminology"},{"location":"live_update/#2-update-procedure-overview","text":"The following flowchart depicts the update procedure from the perspective of the Touch Encoder. Note : The live update procedure is divided into two stages, Upload Stage (light blue) and Update Stage (light red). Each of the stages is covered in a greater detail in subsequent sections.","title":"2. Update Procedure Overview"},{"location":"live_update/#21-upload-stage","text":"Upload stage starts immediately after the live update has been requested and the positive acknowledgment has been sent to the origin. TE assumes a receiver role, disables all input and blocks all other communication. At this time, TE starts accepting data packets that will together compose the update source . The packets are expected to be sent sequentially in-order to yield correct assembly at the destination. The TE relies on the transport layer to guarantee in-order reception.","title":"2.1 Upload Stage"},{"location":"live_update/#211-failure-conditions","text":"Each of the following conditions causes the update procedure to be aborted. At the same time, a Download Status message with appropriate error value is sent to the origin and any following data packets are met with negative acknowledgment. timeout - TE allows up to 1000 ms for each consecutive data packet to arrive, therefore a timeout event is raised if a packet is not seen within this window. overflow - The exact number of bytes is expected to be received. Uploading more bytes than claimed is an error. underflow - Uploading less bytes than the declared amount is a distinct failure condition but the consequence is equivalent to that of a timeout . IO error - Any error that TE encounters when assembling the update source .","title":"2.1.1 Failure conditions"},{"location":"live_update/#212-success-condition","text":"Occurs when the exact number of bytes have been transferred. The TE emits Download Status with error value of 0 and immediately enters the Update Stage upon successfully completing the Upload Stage .","title":"2.1.2 Success Condition"},{"location":"live_update/#22-update-stage","text":"Following a successful Upload Stage TE will attempt to use the uploaded file as the update source . At this stage the origin assumes the listener role since the TE will periodically send out status messages as the update process advances. One type of status messages in the Update Stage is Component Status . These messages provide feedback about the specific update component currently being installed. Another type in this stage is Update Status . Such messages, if they contain a non-zero status value, are terminal. Both types are briefly discussed in the following sections.","title":"2.2 Update Stage"},{"location":"live_update/#221-component-status-message","text":"The following briefly describes each variant of a component status message: - Component Progress - reports component completion state as a percent value - Component Busy - component is installing but the progress is indeterminate - Component End - component installation has concluded with a specific status code","title":"2.2.1 Component Status Message"},{"location":"live_update/#222-update-status-message","text":"As mentioned before, messages of this type mark the end of the update process. The exception to this is the periodically emitted message carrying status value of 0 . In all other cases, the status value is used to determine the overall result of the update process. The meaning of each value is given as follows. -2 - update failed due to an error in the update component . The exact problem can be identified by investigating the last Component End message. -1 - update failed due to an event other than the one captured in status value -2 . 1 - update procedure succeeded and the changes were already applied. 2 - update succeeded but the changes will be applied upon restart. 3 - all corresponding components are up-to-date and no update is necessary.","title":"2.2.2 Update Status Message"},{"location":"live_update/#23-post-update","text":"In this stage, there are three possible courses of action. The choice is dependent on the success or failure of the update procedure. Regardless of the course taken, the TE restores all communication. Restart - Upon update status value of 2 , the TE is set to restart after 10 seconds. With the communication enabled, the origin can issue an immediate restart. Fully Operational State - The TE resumes its normal operation as a result of update status value of 3 , the up-to-date result. The same is true in case of a failed upload. Semi-operational State - This state results from a failed Update Stage . The TE remains with disabled input. With the communication restored, it is possible to reattempt the live update procedure.","title":"2.3 Post-update"},{"location":"live_update/#3-transport-specific-items","text":"","title":"3. Transport-specific Items"},{"location":"live_update/#31-sae-j1939","text":"Please refer to our SAE J1939 guide in order to learn how to issue the live update request. For reliable data transfer we require the use of J1939 TP, preferably with the largest possible MTU of 1785 bytes (7 * 255). Using a smaller transmission size has the potential of the overhead dominating the payload and negatively affecting the update process duration. Transferring the entire update source using just CAN datagrams is discouraged. It is extremely prone to errors with both source and destination going out of sync. We cannot make any correctness guarantees with this choice of transport.","title":"3.1 SAE J1939"},{"location":"live_update/#32-hid","text":"(COMING SOON)","title":"3.2 HID"},{"location":"live_update/#4-appendix","text":"","title":"4. Appendix"},{"location":"live_update/#41-component-type-values","text":"Name Value Package 0 Bootloader 1 Firmware 2 Project 3","title":"4.1 Component Type Values"},{"location":"live_update/#42-status-messages","text":"","title":"4.2 Status Messages"},{"location":"live_update/#421-download-status","text":"Start Length Desc. Values 1.1 1 Byte Type 0x01 - Download Status 2.1 1 Byte Error 0 - No Error 1 - Unknown 2 - Timeout 3 - Overflow 4 - IO Error","title":"4.2.1 Download Status"},{"location":"live_update/#422-update-status","text":"Start Length Desc. Values 1.1 1 Byte Type 0x02 - Update Status 2.1 1 Byte Status -2 - Update failure (component failure) -1 - Update failure 0 - Update Ongoing 1 - Update Success 2 - Update Success (restart required) 3 - Update Success (up-to-date)","title":"4.2.2 Update Status"},{"location":"live_update/#423-component-status","text":"Component Busy Start Length Desc. Values 1.1 1 Byte Type 0x03 - Component Status 2.1 1 Byte Component Type Component Type Value 3.1 1 Byte Component Status 0xB1 - Busy 4.1 4 Bytes Padding 0x00000000 Component Progress Start Length Desc. Values 1.1 1 Byte Type 0x03 - Component Status 2.1 1 Byte Component Type Component Type Value 3.1 1 Byte Component Status 0x30 - Progress 4.1 4 Bytes Progress [ 0 .. 100 ] - percent value Component End Start Length Desc. Values 1.1 1 Byte Type 0x03 - Component Status 2.1 1 Byte Component Type Component Type Value 3.1 1 Byte Component Status 0xF1 - End 4.1 4 Bytes Status Code Component Status Code","title":"4.2.3 Component Status"},{"location":"live_update/#43-component-status-codes","text":"Note : The table below is not comprehensive and contains only the most common codes. Value Description 0x00000000 OK 0x00000001 Up-to-date 0x00010001 Failed opening update source 0x00020001 --- || --- 0x00050001 --- || --- 0x00010002 No project found 0x00020005 File failed validation","title":"4.3 Component Status Codes"},{"location":"comm_protocols/hidusb/","text":"HID USB Documentation 1. Overview The USB interface of the Touch Encoder product is designed to conform to the USB 2.0 specification and, specifically, the USB HID protocol. This protocol allows system integrators to retrieve the data from, or send data to, the device using the ubiquitous USB HID support in the host OS. For more information about the USB standard or the USB HID support in your specific host OS, please visit the USB web site (usb.org) or contact the OS vendor. The Touch Encoder device connects to the host as a composite USB device with two Generic HID interfaces. The HID interfaces consist of several top-level collections (TLC) to virtually separate different device functions. Each report type generated by either the host (OUT) or the device (IN) will have a unique report ID to denote which interface and TLC it is associated with. The Generic HID interfaces are primarily used to send data to the host application. However, they also allow the host application to make changes to the configuration of the device, including screen/widget settings. In order to identify the Touch Encoder within the OS, use the following USB Vendor ID (VID), Product ID (PID) combination: VID 0x1658 Grayhill, Inc. PID 0x0060 Touch Encoder, 2nd generation Touch Encoder 2. Generic HID Interfaces The Touch Encoder device\u2019s Generic HID Interfaces are designed to interface with the generic HID support in the host OS. This means that the host OS does not consume the data itself, but that the data needs to be retrieved (IN report) or transmitted (OUT report) by an application or a driver running on the host device. When new information is available from the device, a new report of the appropriate type is generated. Each report type can be generated by the device at a maximum rate of approximately 60 Hz, although it is possible that the device generates mixed-type reports at a faster rate. The different types of USB reports for this interface are explained below. 2.1 USB Reports 2.1.1 Events Data Report (IN) Interface #: 1 Collection #: 1 Report ID #: 1 The Events Report is the lowest-level report generated by the Touch Encoder device. Even though the Touch Encoder is designed to automatically respond to events occurring on the device, it will use this type of report to keep the host application informed about those events as well. In addition to the Events Data report, the device will also send a Widgets Data (IN) report to the host when an event causes a new widget/screen to be displayed on the device or causes one of the widget values to change. This method of sending a widget report as well as the underlying event report is implemented in order to allow the host to closely monitor the activity of the device, and for the host to respond appropriately should a data mismatch occur. The Events report is 8 bytes long and contains the report ID byte followed by the current event data. The event data consists of a Screen Number byte, a reserved byte, an Event ID byte, an Encoder byte, a Tap Mask word and a Swipe byte. The Encoder byte is a signed 8-bit value containing the relative change in encoder position since the last event report. It uses a special signing, like that used in the Touch Encoder CAN protocol, where a value of 0 is shown as 0x80. For example, if the encoder was turned two detents in the positive (CW) direction since the last report, the Encoder byte would be 0x82. Similarly, if the encoder was turned three detents in the negative (CCW) direction since the last report, the Encoder byte would be 0x7D (notation for -3). In case the encoder was not turned but the Events report was transmitted because another event value changed, then the encoder byte would remain 0x80. The Tap Mask word is a 16-bit value containing the tap information currently available. The most significant bit of the 16-bit value shows whether or not a tap occurred since the last Event report. The remaining 15 bits contain a bit mask of the tap zones the tap occurred in. The bit mask is defined as follows: Bit # Zone # Bit0 Zone 0 Bit1 Zone 1 Bit2 Zone 2 Bit3 Zone 3 Bit4 Zone 4 Bit5 Zone 5 Bit6 Zone 6 Bit7 Zone 7 Bit8 Zone 8 Bit9 Zone 9 Bit10 Zone 10 Bit11 Zone 11 Bit12 Zone 12 Bit13 Zone 13 Bit14 Zone 14 The Swipe Mask byte is an 8-bit value containing the swipe information currently available. The most significant bit of this byte shows whether or not a swipe occurred since the last Event report. The least significant 4 bits contain a bit mask of the direction in which the swipe occurred. The bit mask is defined as follows: Bit # Swipe gesture Bit0 Up Bit1 Down Bit2 Left Bit3 Right 2.1.2 Command Report (OUT) Interface #1 Collection #2 Report ID #2 The Command Report is the lowest-level control available to the USB host controller. It allows modification of system-level attributes, such as the display\u2019s backlight level. The Command Report is 9 bytes long, with the first byte being the Report ID, the second byte being the Command ID, and the remaining 7 bytes being reserved for any Command-specific data. The 8 bytes following the Report ID are meant to emulate the 8 byte Command messages in the Touch Encoder\u2019s CAN J1939 protocol, simplifying documentation and implementation for both, the host device and the Touch Encoder. Currently, only the Backlight Control and Reboot Device commands are supported in the Touch Encoder USB protocol. 2.1.2.1 Backlight Control The backlight control command report uses a Command ID of 0x80 (128) and the second command-specific data byte as the new percentage of backlight brightness. The permitted range for the new percentage (data byte 2) is from 0x00 (0%) to 0x64 (100%). As an example, the report to change the backlight to 100% would look like: Interface #1, Collection #2, OUT: [ 02 80 00 64 xx xx xx xx xx ] Similarly, the report to change the backlight to 30% would look like: Interface #1, Collection #2, OUT: [ 02 80 00 1E xx xx xx xx xx ] 2.1.2.2 Reboot Device The reboot device command report uses a Command ID of 0x44 (68). As an example, the report to reboot the TE device would look like: Interface #1, Collection #2, OUT: [ 02 44 xx xx xx xx xx xx xx ] 2.1.3 Widget Data Report (IN) Interface #: 2 Collection #: 1 Report ID #: 3 This type of report is sent automatically by the device to the host whenever an event on the device causes a new screen to be displayed or causes one of the current screen\u2019s \u201cValue ID\u201d values to change. This type of report is used to keep the host informed about the widgets and \u201cin-sync\u201d with the device. The Screen Number byte is an 8-bit value containing the screen number currently being displayed on the device. The Active Value ID Bitmask byte is a bitmask of the individual Value IDs that are currently active on the screen. There are 8 Value IDs available per screen ranging from 0x01 to 0x80. For each of the Value IDs listed in the Active Value ID Bitmask, one of the following Value ID Information Sections is populated. The Value ID Information Section contains current value information for each of the up to eight active Value IDs on the current screen. Each field in this section contains a Value ID byte, a Current Value associated with that Value ID and a Display Code. The Current Value field is constrained by the initial conditions, minimum and maximum values, and the step constraints defined during the design stage in the IDE. However, the host has the ability to overwrite or initialize the Current Value field. The Display Code field contains a code specifying the format to apply to the Current Value before it is displayed on the widget. 2.1.4 Modify Widget Data Report (OUT) Interface #: 2 Collection #: 2 Report ID #: 4 2.1.4.1 Display Code and Decimal Code The Display Code can allow the Touch Encoder to display decimal values within text boxes, while still using the 16-bit integer values for the respective Value ID\u2019s. To do this, we use the top 4 bits of the Display Code as a signed 4-bit integer (which we call the Decimal Code). This integer is used as an exponent value with a base of 10, like in scientific notation. As a quick note, this Decimal Code is only relevant for Value ID\u2019s which are used by text boxes. Display Code Input Output 0x1X 10 100 0x2X 100 1000 . . . 0xEX 10 0.1 0xFX 100 1 2.1.4.2 Screen Transition Suppression The Screen Transition Suppressor (STS) enables the Touch Encoder to modify variable data of the target screen without first transitioning to that screen. If the corresponding bit is set, the Touch Encoder will not perform a screen transition prior to applying a data change. This feature is only available for Firmware version 3.1.0 or higher. Value Action 0xX0 Value update & screen change 0xX1 Value update only (no screen change) 2.1.4.3 Update Widget Data Examples Example 1 The figure below displays an example of updating the gauge widget data. The ring gauge object is designated as Value ID #1 and set as screen 7. Interface #1, Collection #4, OUT: [04] [07] [03] [00] [01] [57] [00] [00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx Example 2 The figure below displays an example of updating the ring gauge widget data to 5 and -5. Radio Ring Gauge 1 Radio Ring Gauge 2 The ring gauge object is designated as Value ID #1 and set as screen 9. Interface #1, Collection #4, OUT: [04] [09] [03] [00] [01] [05] [00] [00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx [04] [09] [03] [00] [01] [FB] [FF] [00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx Example 3 The figure below displays an example of updating lighted Icons. The ring gauge object is designated as Value ID #1 and set as screen 6. Interface #1, Collection #4, OUT: Light up icon 1 background. [04] [06] [03] [00] [01] [01 80] [00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx Light up icon 2 background. [04] [06] [03] [00] [01] [02 80] [00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx Light up icon 3 background. [04] [06] [03] [00] [01] [04 80] [00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx Light up icon 4 background. [04] [06] [03] [00] [01] [08 80] [00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx Light up icon 1 and 2 background. [04] [06] [03] [00] [01] [03 80] [00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx Light up icon 1, 2, and 3 background. [04] [06] [03] [00] [01] [07 80] [00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx Light up icon 1, 2, 3 and 4 background. [04] [06] [03] [00] [01] [0F 80] [00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx Example 4 The figure below displays an example of a multi-value widget. The dynamic text object is designated at Value ID #1. The lighted icon object is designated as Value ID #3. Below is the sequence of messages to turn on the top lighted icon and change the dynamic text to 100 (note that the lighted icon object has an offset of 0x8000). Interface #1, Collection #4, OUT: Light up icon 1 and change the dynamic text to decimal 53. [04] [0C] [05] [00] [01 35 00 00] [00 00 00 00] [04 01 80 00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx Light up icon 2 and change the dynamic text to decimal 54. [04] [0C] [05] [00] [01 36 00 00] [00 00 00 00] [04 02 80 00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx Light up icon 3 and change the dynamic text to decimal 55. [04] [0C] [05] [00] [01 37 00 00] [00 00 00 00] [04 04 80 00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx Light up icon 4 and change the dynamic text to decimal 56. [04] [0C] [05] [00] [01 38 00 00] [00 00 00 00] [04 08 80 00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx Light up icon 5 and change the dynamic text to decimal 57. [04] [0C] [05] [00] [01 39 00 00] [00 00 00 00] [04 10 80 00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx 3. Mouse HID Interface The Mouse HID interface of the Touch Encoder is designed to interface directly with the mouse driver of the host OS. The interface generates USB reports that contain relative motion, as well as left, and right mouse button click data. The firmware on the Touch Encoder is responsible for processing the hardware button data and the touch data reported by the touch controller, and converting this data into the mouse data format. This processing includes converting individual touch points (as reported by the touch controller) to relative mouse motion data, smoothing the motion data to reduce noise while keeping the processing latency as low as possible, and calculating the duration of individual touches to determine if a tap or other single-touch gesture occurred. The supported single-touch gestures are as follows: Tap \u2013 touch did not move significantly and was shorter than approximately 360 milliseconds in duration Drag Enable \u2013 touch did not move significantly and was longer than 1 second in but shorter than 2 seconds in duration Right-Click \u2013 touch did not move significantly and was longer than 2 seconds in duration The \u201cTap\u201d gesture is realized by sending a single report with the left-click button active, which also allows the use of a double-tap to generate a double-click. If the \u201cDrag Enable\u201d gesture mentioned above is followed by (significant) relative motion of the touch on the touch pad surface, then the firmware will send persistent left-click reports for as long as the touch is active on the pad. This allows for items to be \u201cpinned\u201d by performing the gesture and then moving them across the screen. The dragging stops when the touch is lifted off the screen. The \u201cRight-Click\u201d gesture mentioned above causes the device to send a single report with the right-click button active. This results in a right-click menu being opened. The user can then use simple touch motion to move the mouse cursor to the desired menu selection. 3.1 USB Reports 3.1.1 Mouse Report (IN) Name Byte # Value Report ID 6 1 0000 0110 Mouse Button Mask 2 0000 00XX X Relative Position 3-4 XXXX XXXX XXXX XXXX Y Relative Position 5-6 XXXX XXXX XXXX XXXX Relative Wheel Data 7 XXXX XXXX Reserved 8 XXXX XXXX This type of report is 8 bytes long and contains the report ID byte, followed by 1 byte of button mask data, 2 bytes of relative X position data, 2 bytes of relative Y position data, 1 byte of relative wheel data, and 1 reserved byte. The button mask indicates whether the left (bit 0) or right (bit 1) buttons are either active (1) or inactive (0). The button bits reflect the output of the single-touch gesture recognition mentioned above. The Relative Wheel Data contains the TE encoder output. The final byte is currently reserved for future use. While touches are being sensed on the touch surface, this report is generated at a rate of approximately 60 Hz.","title":"HID USB"},{"location":"comm_protocols/hidusb/#hid-usb-documentation","text":"","title":"HID USB Documentation"},{"location":"comm_protocols/hidusb/#1-overview","text":"The USB interface of the Touch Encoder product is designed to conform to the USB 2.0 specification and, specifically, the USB HID protocol. This protocol allows system integrators to retrieve the data from, or send data to, the device using the ubiquitous USB HID support in the host OS. For more information about the USB standard or the USB HID support in your specific host OS, please visit the USB web site (usb.org) or contact the OS vendor. The Touch Encoder device connects to the host as a composite USB device with two Generic HID interfaces. The HID interfaces consist of several top-level collections (TLC) to virtually separate different device functions. Each report type generated by either the host (OUT) or the device (IN) will have a unique report ID to denote which interface and TLC it is associated with. The Generic HID interfaces are primarily used to send data to the host application. However, they also allow the host application to make changes to the configuration of the device, including screen/widget settings. In order to identify the Touch Encoder within the OS, use the following USB Vendor ID (VID), Product ID (PID) combination: VID 0x1658 Grayhill, Inc. PID 0x0060 Touch Encoder, 2nd generation Touch Encoder","title":"1. Overview"},{"location":"comm_protocols/hidusb/#2-generic-hid-interfaces","text":"The Touch Encoder device\u2019s Generic HID Interfaces are designed to interface with the generic HID support in the host OS. This means that the host OS does not consume the data itself, but that the data needs to be retrieved (IN report) or transmitted (OUT report) by an application or a driver running on the host device. When new information is available from the device, a new report of the appropriate type is generated. Each report type can be generated by the device at a maximum rate of approximately 60 Hz, although it is possible that the device generates mixed-type reports at a faster rate. The different types of USB reports for this interface are explained below.","title":"2. Generic HID Interfaces"},{"location":"comm_protocols/hidusb/#21-usb-reports","text":"","title":"2.1 USB Reports"},{"location":"comm_protocols/hidusb/#211-events-data-report-in","text":"Interface #: 1 Collection #: 1 Report ID #: 1 The Events Report is the lowest-level report generated by the Touch Encoder device. Even though the Touch Encoder is designed to automatically respond to events occurring on the device, it will use this type of report to keep the host application informed about those events as well. In addition to the Events Data report, the device will also send a Widgets Data (IN) report to the host when an event causes a new widget/screen to be displayed on the device or causes one of the widget values to change. This method of sending a widget report as well as the underlying event report is implemented in order to allow the host to closely monitor the activity of the device, and for the host to respond appropriately should a data mismatch occur. The Events report is 8 bytes long and contains the report ID byte followed by the current event data. The event data consists of a Screen Number byte, a reserved byte, an Event ID byte, an Encoder byte, a Tap Mask word and a Swipe byte. The Encoder byte is a signed 8-bit value containing the relative change in encoder position since the last event report. It uses a special signing, like that used in the Touch Encoder CAN protocol, where a value of 0 is shown as 0x80. For example, if the encoder was turned two detents in the positive (CW) direction since the last report, the Encoder byte would be 0x82. Similarly, if the encoder was turned three detents in the negative (CCW) direction since the last report, the Encoder byte would be 0x7D (notation for -3). In case the encoder was not turned but the Events report was transmitted because another event value changed, then the encoder byte would remain 0x80. The Tap Mask word is a 16-bit value containing the tap information currently available. The most significant bit of the 16-bit value shows whether or not a tap occurred since the last Event report. The remaining 15 bits contain a bit mask of the tap zones the tap occurred in. The bit mask is defined as follows: Bit # Zone # Bit0 Zone 0 Bit1 Zone 1 Bit2 Zone 2 Bit3 Zone 3 Bit4 Zone 4 Bit5 Zone 5 Bit6 Zone 6 Bit7 Zone 7 Bit8 Zone 8 Bit9 Zone 9 Bit10 Zone 10 Bit11 Zone 11 Bit12 Zone 12 Bit13 Zone 13 Bit14 Zone 14 The Swipe Mask byte is an 8-bit value containing the swipe information currently available. The most significant bit of this byte shows whether or not a swipe occurred since the last Event report. The least significant 4 bits contain a bit mask of the direction in which the swipe occurred. The bit mask is defined as follows: Bit # Swipe gesture Bit0 Up Bit1 Down Bit2 Left Bit3 Right","title":"2.1.1 Events Data Report (IN)"},{"location":"comm_protocols/hidusb/#212-command-report-out","text":"Interface #1 Collection #2 Report ID #2 The Command Report is the lowest-level control available to the USB host controller. It allows modification of system-level attributes, such as the display\u2019s backlight level. The Command Report is 9 bytes long, with the first byte being the Report ID, the second byte being the Command ID, and the remaining 7 bytes being reserved for any Command-specific data. The 8 bytes following the Report ID are meant to emulate the 8 byte Command messages in the Touch Encoder\u2019s CAN J1939 protocol, simplifying documentation and implementation for both, the host device and the Touch Encoder. Currently, only the Backlight Control and Reboot Device commands are supported in the Touch Encoder USB protocol.","title":"2.1.2 Command Report (OUT)"},{"location":"comm_protocols/hidusb/#2121-backlight-control","text":"The backlight control command report uses a Command ID of 0x80 (128) and the second command-specific data byte as the new percentage of backlight brightness. The permitted range for the new percentage (data byte 2) is from 0x00 (0%) to 0x64 (100%). As an example, the report to change the backlight to 100% would look like: Interface #1, Collection #2, OUT: [ 02 80 00 64 xx xx xx xx xx ] Similarly, the report to change the backlight to 30% would look like: Interface #1, Collection #2, OUT: [ 02 80 00 1E xx xx xx xx xx ]","title":"2.1.2.1 Backlight Control"},{"location":"comm_protocols/hidusb/#2122-reboot-device","text":"The reboot device command report uses a Command ID of 0x44 (68). As an example, the report to reboot the TE device would look like: Interface #1, Collection #2, OUT: [ 02 44 xx xx xx xx xx xx xx ]","title":"2.1.2.2 Reboot Device"},{"location":"comm_protocols/hidusb/#213-widget-data-report-in","text":"Interface #: 2 Collection #: 1 Report ID #: 3 This type of report is sent automatically by the device to the host whenever an event on the device causes a new screen to be displayed or causes one of the current screen\u2019s \u201cValue ID\u201d values to change. This type of report is used to keep the host informed about the widgets and \u201cin-sync\u201d with the device. The Screen Number byte is an 8-bit value containing the screen number currently being displayed on the device. The Active Value ID Bitmask byte is a bitmask of the individual Value IDs that are currently active on the screen. There are 8 Value IDs available per screen ranging from 0x01 to 0x80. For each of the Value IDs listed in the Active Value ID Bitmask, one of the following Value ID Information Sections is populated. The Value ID Information Section contains current value information for each of the up to eight active Value IDs on the current screen. Each field in this section contains a Value ID byte, a Current Value associated with that Value ID and a Display Code. The Current Value field is constrained by the initial conditions, minimum and maximum values, and the step constraints defined during the design stage in the IDE. However, the host has the ability to overwrite or initialize the Current Value field. The Display Code field contains a code specifying the format to apply to the Current Value before it is displayed on the widget.","title":"2.1.3 Widget Data Report (IN)"},{"location":"comm_protocols/hidusb/#214-modify-widget-data-report-out","text":"Interface #: 2 Collection #: 2 Report ID #: 4","title":"2.1.4 Modify Widget Data Report (OUT)"},{"location":"comm_protocols/hidusb/#2141-display-code-and-decimal-code","text":"The Display Code can allow the Touch Encoder to display decimal values within text boxes, while still using the 16-bit integer values for the respective Value ID\u2019s. To do this, we use the top 4 bits of the Display Code as a signed 4-bit integer (which we call the Decimal Code). This integer is used as an exponent value with a base of 10, like in scientific notation. As a quick note, this Decimal Code is only relevant for Value ID\u2019s which are used by text boxes. Display Code Input Output 0x1X 10 100 0x2X 100 1000 . . . 0xEX 10 0.1 0xFX 100 1","title":"2.1.4.1 Display Code and Decimal Code"},{"location":"comm_protocols/hidusb/#2142-screen-transition-suppression","text":"The Screen Transition Suppressor (STS) enables the Touch Encoder to modify variable data of the target screen without first transitioning to that screen. If the corresponding bit is set, the Touch Encoder will not perform a screen transition prior to applying a data change. This feature is only available for Firmware version 3.1.0 or higher. Value Action 0xX0 Value update & screen change 0xX1 Value update only (no screen change)","title":"2.1.4.2 Screen Transition Suppression"},{"location":"comm_protocols/hidusb/#2143-update-widget-data-examples","text":"","title":"2.1.4.3 Update Widget Data Examples"},{"location":"comm_protocols/hidusb/#example-1","text":"The figure below displays an example of updating the gauge widget data. The ring gauge object is designated as Value ID #1 and set as screen 7. Interface #1, Collection #4, OUT: [04] [07] [03] [00] [01] [57] [00] [00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx","title":"Example 1"},{"location":"comm_protocols/hidusb/#example-2","text":"The figure below displays an example of updating the ring gauge widget data to 5 and -5. Radio Ring Gauge 1 Radio Ring Gauge 2 The ring gauge object is designated as Value ID #1 and set as screen 9. Interface #1, Collection #4, OUT: [04] [09] [03] [00] [01] [05] [00] [00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx [04] [09] [03] [00] [01] [FB] [FF] [00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx","title":"Example 2"},{"location":"comm_protocols/hidusb/#example-3","text":"The figure below displays an example of updating lighted Icons. The ring gauge object is designated as Value ID #1 and set as screen 6. Interface #1, Collection #4, OUT: Light up icon 1 background. [04] [06] [03] [00] [01] [01 80] [00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx Light up icon 2 background. [04] [06] [03] [00] [01] [02 80] [00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx Light up icon 3 background. [04] [06] [03] [00] [01] [04 80] [00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx Light up icon 4 background. [04] [06] [03] [00] [01] [08 80] [00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx Light up icon 1 and 2 background. [04] [06] [03] [00] [01] [03 80] [00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx Light up icon 1, 2, and 3 background. [04] [06] [03] [00] [01] [07 80] [00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx Light up icon 1, 2, 3 and 4 background. [04] [06] [03] [00] [01] [0F 80] [00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx","title":"Example 3"},{"location":"comm_protocols/hidusb/#example-4","text":"The figure below displays an example of a multi-value widget. The dynamic text object is designated at Value ID #1. The lighted icon object is designated as Value ID #3. Below is the sequence of messages to turn on the top lighted icon and change the dynamic text to 100 (note that the lighted icon object has an offset of 0x8000). Interface #1, Collection #4, OUT: Light up icon 1 and change the dynamic text to decimal 53. [04] [0C] [05] [00] [01 35 00 00] [00 00 00 00] [04 01 80 00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx Light up icon 2 and change the dynamic text to decimal 54. [04] [0C] [05] [00] [01 36 00 00] [00 00 00 00] [04 02 80 00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx Light up icon 3 and change the dynamic text to decimal 55. [04] [0C] [05] [00] [01 37 00 00] [00 00 00 00] [04 04 80 00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx Light up icon 4 and change the dynamic text to decimal 56. [04] [0C] [05] [00] [01 38 00 00] [00 00 00 00] [04 08 80 00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx Light up icon 5 and change the dynamic text to decimal 57. [04] [0C] [05] [00] [01 39 00 00] [00 00 00 00] [04 10 80 00] xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx","title":"Example 4"},{"location":"comm_protocols/hidusb/#3-mouse-hid-interface","text":"The Mouse HID interface of the Touch Encoder is designed to interface directly with the mouse driver of the host OS. The interface generates USB reports that contain relative motion, as well as left, and right mouse button click data. The firmware on the Touch Encoder is responsible for processing the hardware button data and the touch data reported by the touch controller, and converting this data into the mouse data format. This processing includes converting individual touch points (as reported by the touch controller) to relative mouse motion data, smoothing the motion data to reduce noise while keeping the processing latency as low as possible, and calculating the duration of individual touches to determine if a tap or other single-touch gesture occurred. The supported single-touch gestures are as follows: Tap \u2013 touch did not move significantly and was shorter than approximately 360 milliseconds in duration Drag Enable \u2013 touch did not move significantly and was longer than 1 second in but shorter than 2 seconds in duration Right-Click \u2013 touch did not move significantly and was longer than 2 seconds in duration The \u201cTap\u201d gesture is realized by sending a single report with the left-click button active, which also allows the use of a double-tap to generate a double-click. If the \u201cDrag Enable\u201d gesture mentioned above is followed by (significant) relative motion of the touch on the touch pad surface, then the firmware will send persistent left-click reports for as long as the touch is active on the pad. This allows for items to be \u201cpinned\u201d by performing the gesture and then moving them across the screen. The dragging stops when the touch is lifted off the screen. The \u201cRight-Click\u201d gesture mentioned above causes the device to send a single report with the right-click button active. This results in a right-click menu being opened. The user can then use simple touch motion to move the mouse cursor to the desired menu selection.","title":"3. Mouse HID Interface"},{"location":"comm_protocols/hidusb/#31-usb-reports","text":"","title":"3.1 USB Reports"},{"location":"comm_protocols/hidusb/#311-mouse-report-in","text":"Name Byte # Value Report ID 6 1 0000 0110 Mouse Button Mask 2 0000 00XX X Relative Position 3-4 XXXX XXXX XXXX XXXX Y Relative Position 5-6 XXXX XXXX XXXX XXXX Relative Wheel Data 7 XXXX XXXX Reserved 8 XXXX XXXX This type of report is 8 bytes long and contains the report ID byte, followed by 1 byte of button mask data, 2 bytes of relative X position data, 2 bytes of relative Y position data, 1 byte of relative wheel data, and 1 reserved byte. The button mask indicates whether the left (bit 0) or right (bit 1) buttons are either active (1) or inactive (0). The button bits reflect the output of the single-touch gesture recognition mentioned above. The Relative Wheel Data contains the TE encoder output. The final byte is currently reserved for future use. While touches are being sensed on the touch surface, this report is generated at a rate of approximately 60 Hz.","title":"3.1.1 Mouse Report (IN)"},{"location":"comm_protocols/sae_j1939/","text":"SAE J1939 Documentation 1. Overview This document describes the functionality and communication of the Grayhill Touch Encoder product. 1.1 Reference Documents The following documents are referenced within this document. SAE-J1939 SAE-J1939/11 SAE-J1939/21 SAE-J1939/71 SAE-J1939/81 2. J1939 Communications 2.1 Message Header Description The figure below illustrates the format of the CAN message ID. A brief description of each field follows. 2.1.1 Priority This 3-bit field is used to define the priority during arbitration. 0 is the highest priority and is usually associated with high-speed control messages. Low priority is used for non-critical configuration and information messages. The lowest priority value is 7. 2.1.2 Data Page (DP) This 1-bit field defines on which data page (0 or 1) the message is defined in the J1939 specification. Page 0 contains the messages that are presently defined, while Page 1 is for future expansion according to J1939. 2.1.3 Protocol Data Unit (PDU) - PDU Format (PF) This 8-bit field determines the format of the message and is one of the fields which determine the Parameter Group Number of the message (see 2.1.6). If the value is between 0 and 239, the message is a PDU 1 format message. These messages are sent to specific addresses. If the value is between 240 and 255, the message is a PDU 2 format message. These messages are not sent to a specific address, but are instead broadcast to the entire network. 2.1.4 Protocol Data Unit (PDU) - PDU Specific (PS) The PDU Specific (PS) field is the Destination Address (DA) in a PDU 1 Format. In a PDU 2 format the PS becomes the Group Extension (GE). This field is 8 bits long. 2.1.5 Source Address This 8-bit field is the source address of the device that sent the message. 2.1.6 Parameter Group Number J1939 defines allowable messages by their Parameter Group Number (PGN). The Parameter Group Number is an 18-bit value that uniquely defines the message purpose. It is composed of the Reserved bit, DP, PF and PS, all of which are described above. 2.2 J1939 Bit Field Location and Byte Ordering The first data byte is sent first and is referenced as Byte 1. The LSB of the data bytes are on the right and are referenced as Bit 1. All multibyte data fields are specified in little-endian byte order unless stated otherwise. The convention used to locate a parameter in the data field is the same as specified in SAE-J1939/71. The format used is \"R.x\" where R is the byte number and x is the starting bit number within the byte. The length is the number of bits starting at this point. Example : Location 4.3 with a length of 3 bits would have the value of 1 as illustrated below. Byte 4 = 0x67 = 0b011 001 11. The bold value is the three bit field holding a value of 0b001. Example : Location 4.3 with a length of 3 bits would have the value of 6 as illustrated below. Byte 4 = 0x7b = 0b011 110 11. The bold value is the three bit field holding a value of 0b110. 2.3 Grayhill Touch Encoder Source Address The source address of the Grayhill Touch Encoder device is set to 242 (0xF2) at the factory. This may be modified dynamically with the proprietary Source Address Command. The source address value is stored in non-volatile memory. Touch Encoder assumes this value at startup but the actual source address is the result of Dynamic Adressing. Multiple Touch Encoder devices can coexist in the same system. 2.4 Standard Messages The Events Data message and the Widget Data message all use the Proprietary B PDU2 format (PF = 255) that broadcasts to no specific address the status of the device. The Control Data message uses Proprietary A PDU1 format (PF = 239). 2.4.1 Events Data Message Priority \u2013 0b110 (6) R/DP \u2013 0b00 (0) PF \u2013 0xFF (255), Proprietary B PDU2 Format GrpExt \u2013 0x0F (15) SrcAddr \u2013 0xF2 (242), i.e. Touch Encoder default source address ID \u2013 0x18FF0FF2 Direction \u2013 Transmit Data Length \u2013 8 bytes Transmission Rate \u2013 On Event (programmable) * The Events Data PGN can be reassigned using a configuration command. Start Length Desc. Values 1.1 8 bits Screen Number 0x01 \u2013 Screen #1 at the time of event \u2026 0xFF \u2013 Screen #255 at the time of event 2.1 8 bits Reserved Reserved for future use 3.1 8 bits Event ID 0x01- Events: Standard (Relative Encoder, Taps, Swipes) 4.1 8 bits Encoder (relative) 0x80 \u2013 No Change 0x81 \u2013 Clockwise 1 detent 0x82 \u2013 Clockwise 2 detents \u2026 0xFE \u2013 Clockwise 126 detents 0x7F \u2013 Counter-Clockwise 1 detent 0x7E \u2013 Counter-Clockwise 2 detents \u2026 0x01 \u2013 Counter-Clockwise 127 detents 0x00 \u2013 Not used 0xFF \u2013 Not used 5.1 16 bits Tap Mask* 0x0000 \u2013 No Tap detected 0x0001 \u2013 Tap in Zone 1 detected 0x0002 \u2013 Tap in Zone 2 detected 0x0004 \u2013 Tap in Zone 3 detected \u2026 0x4000 \u2013 Tap in Zone 15 detected 0x8000 \u2013 Tap on screen (anywhere) detected 7.1 8 bits Swipe Mask 0x00 \u2013 No Swipe detected 0x01 \u2013 Swipe Up detected 0x02 \u2013 Swipe Down detected 0x03 \u2013 Swipe Left detected 0x04 \u2013 Swipe Right detected 0x80 \u2013 Swipe (any direction) detected * This field is specified in big-endian byte order. The Events Data message is sent to inform the receiving (host) ECU of any new encoder, tap or swipe events that occurred on the Touch Encoder device. If such an event causes a new screen to be displayed or if any of the Value IDs on the current screen were changed, the event is followed by a Widget Data message or messages which, on a screen change, will communicate the data in all Value IDs on the new screen. Example : Turning the encoder counter-clockwise by 2 detents on screen 1 (since last message) will result in the following message being transmitted. ID=0x18FF0FF2, LEN=8, DATA=0x01,0x00,0x01,0x7E,0x00,0x00,0x00,0xFF Example : Swiping up on the touch pad on screen 5 will result in the following message being transmitted. ID=0x18FF0FF2, LEN=8, DATA=0x05,0x00,0x01,0x80,0x00,0x00,0x81,0xFF Example : Tapping in screen 10 zone 4 of the touch pad will result in the following message being transmitted. ID=0x18FF0FF2, LEN=8, DATA=0x0A,0x00,0x01,0x80,0x80,0x08,0x00,0xFF 2.4.2 Widget Data Message Priority \u2013 0b110 (6) R/DP \u2013 0b00 (0) PF \u2013 0xFF (255), Proprietary B PDU2 Format GrpExt \u2013 0x11 (17) SrcAddr \u2013 0xF2 (242), i.e. Touch Encoder default source address ID \u2013 0x18FF11F2 Direction \u2013 Transmit Data Length \u2013 8 bytes Transmission Rate \u2013 On Event (programmable) * The Widget Data PGN can be reassigned using a configuration command. As described in the previous section, if an event on the Touch Encoder Device causes a new screen to be displayed or if the event causes a change in one of the active Value IDs on the current screen, the Events Data message is immediately followed by a Widget Data message. Due to CAN restrictions on the number of data bytes allowed per CAN frame, Widget Data reports with multiple Value IDs need to split up into several messages. The number of messages needed is the number of Value IDs. For instance, for a single active Value ID, only one message is needed. For multiple active Value IDs, multiple messages are sent consecutively, each for a single Value ID. Start Length Desc. Values 1.1 8 bits Screen Number 0x01 \u2013 Screen #1 currently being displayed \u2026 0xFF \u2013 Screen #255 currently being displayed 2.1 8 bits Reserved Reserved for future use 3.1 8 bits Value ID 0x00 \u2013 No Values on this screen 0x01 \u2013 Value ID #1 0x02 \u2013 Value ID #2 0x04 \u2013 Value ID #3 \u2026 0x80 \u2013 Value ID #8 4.1 16 bits Current Value Value currently being displayed for the given Value ID 6.1 4 bits Reserved 0 6.5 4 bits Display Code Display Code (Decimal Code) for this Value 7.1 8 bits Active Value ID Bitmask 0x00 \u2013 Not used 0x01 \u2013 Value ID (Value #1 is active for this screen) 0x02 \u2013 Value ID (Value #2 is active for this screen) \u2026 0xFF \u2013 Value ID (All 8 Values active for this screen) Example : For two active Value IDs, two separate messages are needed to convey all of the Widget information. Below is an example of the messages with a widget that has two ValueIDs. The first being a temperature setting of 75 and the second being a fan speed of 5. ID=0x18FF11F2, LEN=8, DATA=0x01,0x00,0x01,0x4B,0x00,0x00,0x03,0xFF ID=0x18FF11F2, LEN=8, DATA=0x01,0x00,0x02,0x05,0x00,0x00,0x03,0xFF 2.4.3 Configuration and Control Message Priority \u2013 0b110 (6) R/DP \u2013 0b00 (0) PF \u2013 0xEF (239) Proprietary A PDU1 Format PS \u2013 DestAddr, i.e. address of the Touch Encoder device, default value: 242 (0xF2) SrcAddr \u2013 0x21 (33), i.e. example source address ID \u2013 0x18EFF221 Direction \u2013 Receive Data Length \u2013 8 Start Length Desc. Values 1.1 1 Byte Configuration and Control Command Command Byte as described in sec. 3 2.1 7 Bytes Configuration and Control Data Variable as described in sec. 3 3. Configuration and Control Commands Changing of the configuration and how the Touch Encoder device behaves is done with the Configuration and Control message described in section 2.4.3. The first byte serves as the command byte. Where applicable, changes take effect immediately and are stored in non-volatile memory unless otherwise noted. The header information for these commands is as follows: Priority \u2013 0b110 (6) R/DP \u2013 0b00 (0) PF \u2013 0xEF (239) PS \u2013 DestAddr, i.e. address of the Touch Encoder device, default value: 0xF2 (242) SrcAddr \u2013 0x21 (33), i.e. example source address ID \u2013 0x18EFF221, Proprietary A PDU1 Format Direction \u2013 Receive 3.1 Modify Widget Data Data Length \u2013 7 bytes Start Length Desc. Values 1.1 8 bits Command 0x11 \u2013 Force Widget Data 2.1 8 bits Screen Number 0x00 \u2013 Screen #0 to be displayed 0x01 \u2013 Screen #1 to be displayed \u2026 0xFF \u2013 Screen #255 to be displayed 3.1 8 bits Value ID 0x00 \u2013 No altered Values 0x01 \u2013 Value ID #1 0x02 \u2013 Value ID #2 0x04 \u2013 Value ID #3 \u2026 0x80 \u2013 ValueID #8 4.1 16 bits Current Value Value to be displayed. This value is of the format specified by Display Code value 6.1 1 bit Screen Transition Suppressor 0 \u2013 Perform screen transition 1 \u2013 Suppress screen transition 6.2 3 bits Reserved 0 6.5 4 bits Display Code Display Code for this Value (Decimal Code) 7.1 8 bits Active Value ID Bitmask 0x00 \u2013 Not used 0x01 \u2013 Value #1 currently active 0x02 \u2013 Value #2 currently active \u2026 0x80 \u2013 All 8 Values currently active Example : Sending the following message to a Touch Encoder device having the default address of 0xF2 will set the current screen to be displayed to 0x03 and the current value of ValueID #2 of that screen to 0x01F4. ID=18EFF221, LEN=8, Data=0x11, 0x03, 0x02, 0xF4, 0x01, 0x00, 0x02, 0xFF 3.1.1 Multi-Value Data Example Example : The figure above displays an example of a multi-value widget. The dynamic text object is designated at Value ID #2. The lighted icon object is designated as Value ID #3. Below is the sequence of messages to turn on the top lighted icon and change the dynamic text to 100. ID=18EFF221, LEN=8, Data=0x11, 0x03, 0x04, 0x01, 0x00, 0x00, 0x06, 0xFF ID=18EFF221, LEN=8, Data=0x11, 0x03, 0x02, 0x64, 0x00, 0x00, 0x06, 0xFF 3.1.2 Display Code The Display Code gives the Touch Encoder the ability to display decimal numbers. The Display Code occupies 4 upper bits of byte 6. The value of this field is interpreted as a signed 4-bit integer that specifies the direction and the amount of decimal places to shift the point by. The alternative name for this field is Decimal Code. The table below describes how the decimal code works. Decimal Code Value Display Value Description 0x0 1 1 Display value directly 0x1 1 10 value x 10 (shift right one place) 0x2 1 100 value x 100 (shift right two places) 0xE 1 0.01 value \u00f7 100 (shift left two places) 0xF 1 0.1 value \u00f7 10 (shift left one place) 3.1.3 Screen Transition Suppression The Screen Transition Suppressor (STS) enables the Touch Encoder to modify variable data of the target screen without first transitioning to that screen. If the corresponding bit is set, the Touch Encoder will not perform a screen transition prior to applying a data change. This feature is available in Touch Encoder firmware version 3.1.0 or higher. 3.2 Modify Events Data PGN Data Length \u2013 8 bytes Byte 1 Byte 2 Byte 3 Byte 4 Byte 5 Byte 6 Byte 7 Byte 8 0xD1 aa bb xx xx xx 0x55 0xAA aa \u2013 The least significant byte of the new PGN. Valid Range: 0..255 bb - The most significant byte of the new PGN. Valid Range: 0..255 xx \u2013 Don't Care. Should be 0xFF following J1939 convention 0x55 \u2013 Low byte of 16 bit key 0xAA \u2013 High byte of 16 bit key 3.3 Modify Events Data Transmission Period Data Length \u2013 8 bytes Byte 1 Byte 2 Byte 3 Byte 4 Byte 5 Byte 6 Byte 7 Byte 8 0xD3 dd Event xx xx xx 0x55 0xAA dd \u2013 specifies transmission period. Valid range is 0..255. The actual period is determined by multiplying the value by 10ms. This yields the minimum of 10ms and the maximum of 2.55 seconds. The value of 0 turns off periodic transmission of the message. Event \u2013 transmit on event. Valid values are 0 and 1. The value of 1 sends the message upon state change. The value of 0 will cause the message to be transmitted only at the specified time interval unless also set to 0. xx \u2013 Don't Care. Should be 0xFF following J1939 convention 0x55 \u2013 Low byte of 16 bit key 0xAA \u2013 High byte of 16 bit key 3.4 Modify Widgets Data PGN Data Length \u2013 8 bytes Byte 1 Byte 2 Byte 3 Byte 4 Byte 5 Byte 6 Byte 7 Byte 8 0xD9 aa bb xx xx xx 0x55 0xAA aa \u2013 The least significant byte of the new PGN. Valid Range: 0..255 bb - The most significant byte of the new PGN. Valid Range: 0..255 xx \u2013 Don't Care. Should be 0xFF following J1939 convention 0x55 \u2013 Low byte of 16 bit key 0xAA \u2013 High byte of 16 bit key 3.5 Modify Widgets Data Transmission Period Data Length \u2013 8 bytes Byte 1 Byte 2 Byte 3 Byte 4 Byte 5 Byte 6 Byte 7 Byte 8 0xDB dd Event xx xx xx 0x55 0xAA dd \u2013 specifies transmission period. Valid range is 0..255. The actual period is determined by multiplying the value by 10ms. This yields the minimum of 10ms and the maximum of 2.55 seconds. The value of 0 turns off periodic transmission of the message. Event \u2013 transmit on event. Valid values are 0 and 1. The value of 1 sends the message upon state change. The value of 0 will cause the message to be transmitted only at the specified time interval unless also set to 0. xx \u2013 Don't Care. Should be 0xFF following J1939 convention 0x55 \u2013 Low byte of 16 bit key 0xAA \u2013 High byte of 16 bit key 3.6 Modify Message Priority Data Length \u2013 8 bytes Byte 1 Byte 2 Byte 3 Byte 4 Byte 5 Byte 6 Byte 7 Byte 8 0xD2 dd xx xx xx xx 0x55 0xAA dd \u2013 The new priority. Valid Range: 0..7 xx \u2013 Don't Care. Should be 0xFF following J1939 convention 0x55 \u2013 Low byte of 16 bit key 0xAA \u2013 High byte of 16 bit key Applies to all messages sent by the Touch Encoder. 3.7 Modify Source Address Data Length \u2013 8 bytes Byte 1 Byte 2 Byte 3 Byte 4 Byte 5 Byte 6 Byte 7 Byte 8 0xE0 dd xx xx xx xx 0x55 0xAA dd \u2013 Has a value between 128 and 245 and is the new source address xx \u2013 Don't Care. Should be 0xFF following J1939 convention 0x55 \u2013 Low byte of 16 bit key 0xAA \u2013 High byte of 16 bit key 3.8 Backlight Intensity Data Length \u2013 8 bytes Byte 1 Byte 2 Byte 3 Byte 4 Byte 5 Byte 6 Byte 7 Byte 8 0x80 xx dd xx xx xx xx xx dd \u2013 Has a value between 0 and 100 and is the percentage of backlight intensity xx \u2013 Don't Care. Should be 0xFF following J1939 convention 3.9 Live Update Request Data Length \u2013 8 bytes Start Length Desc. Values 1.1 1 Byte Command 0x55 - Live Update Request 2.1 1 Byte Component type 0 - package 3 - project 3.1 3 Bytes Upload Size File size in bytes 6.1 3 Bytes PGN PGN value to use for the update session Example : The following message requests the update of Touch Encoder project. The origin (0x21) obligates itself to upload a file of size equal to 2212495 bytes (roughly 2.11MB) over PGN 0x13300. The file, once succesfully submitted, will be used to update the TE project. ID=18EFF221, LEN=8, Data=0x55, 0x03, 0x8F, 0xC2, 0x21, 0x00, 0x33, 0x01 To learn more about the live update procedure, see our Live Update guide . 4. Other J1939 Messages The following messages are defined in the J1939 documents and are implemented in the Touch Encoder device. 4.1 Address Claimed Priority \u2013 0b110 (6) R/DP \u2013 0b00 (0) PF \u2013 0xEE (238), Address Claimed PS \u2013 DestAddr, address should always be the Global Address, 0xFF SrcAddr \u2013 0xF2 (242), i.e. Touch Encoder source address ID \u2013 0x18EEFFF2, Proprietary A PDU1 Format Direction \u2013 Transmit Data Length \u2013 8 bytes Transmission Rate \u2013 Upon boot or whenever requested Start Length Desc. Values 1.1 21 Bits Identity Number Device-unique value 3.6 11 Bits Manufacturers Code 294 (Assigned to Grayhill by SAE) 5.1 3 Bits ECU Instance 0 (Default) 5.4 5 Bits Function Instance 0 (Default) 6.1 8 Bits Function 60 (Cab Display) * 7.1 1 Bit Reserved 0 (Defined by SAE) 7.2 7 Bits Vehicle System 0 (Default) 8.1 4 Bits Vehicle System Instance 0 (Default) 8.5 3 Bits Industry Group 0 Global (Default) 8.8 1 Bit Arbitrary Address Capable 1 Capable (Default) *Refer to J1939 base document for the Function value based on the Industry Group and Vehicle System combinations 4.2 PGN Request Priority \u2013 0b110 (6) R/DP \u2013 0b00 (0) PF \u2013 0xEA (234), PGN Request, Proprietary A PDU1 Format PS \u2013 DestAddr, address of the Touch Encoder device to respond or the Global Address SrcAddr \u2013 0x21 (33), i.e. example source address ID \u2013 0x18EAF221 Direction \u2013 Receive Data Length \u2013 3 Start Length Desc. Values 1 1 Byte Byte 1 of PGN being requested (LSB) 0 to 255 2 1 Byte Byte 2 of PGN being requested 0 to 255 3 1 Byte Byte 3 of PGN being requested (MSB) 0 The following are the supported PGN's that can be requested from the keypad. If the request is unsupported the keypad responds with a NACK (Refer to J1939-21). 4.2.1 ECU Identification Information (COMING SOON) Priority \u2013 0b110 (6) R/DP \u2013 0b00 (0) PF \u2013 0xFD (253), ECU ID, Proprietary B PDU2 Format PS \u2013 0xC5 (197)? SrcAddr \u2013 0xF2 (242), i.e. Touch Encoder source address ID \u2013 0x18FDC5F2 Direction \u2013 Transmit Data Length \u2013 Variable Transmission Rate \u2013 Upon Request Multi Packet Transerred \u2013 Yes, BAM only Start Length Desc. Values * 1 <=64 ECU Part Number Ex. \"3KYY1001-1\" Variable <=64 ECU Serial Number Ex. \"123456\" Variable <=64 ECU Location Ex. \"CAB\" Variable <=64 ECU Type Ex. \"KEYPAD\" *All fields \"*\" ASCII delimited 4.2.2 Software Identification Priority \u2013 0b110 (6) R/DP \u2013 0b00 (0) PF \u2013 0xFE (254), SW ID, Proprietary B PDU2 Format PS \u2013 0xDA (218) SrcAddr \u2013 0xF2 (242), i.e. Touch Encoder source address ID \u2013 0x18FEDAF2 Direction \u2013 Transmit Data Length \u2013 Variable, 13-67 bytes Transmission Rate \u2013 Upon Request Multi Packet Transferred \u2013 Yes, BAM only Start Length Desc. Values 1 1 Byte Number of software fields 2 2 5-N Bytes Firmware version # (Major.Minor.Patch) (ASCII) Ex. 4.3.1 Variable 5-N Bytes Bootloader version # (Major.Minor.Patch) (ASCII) Ex. 7.5.3 *All fields \"*\" ASCII delimited 4.3 Acknowledgement Message Priority \u2013 0b110 (6) R/DP \u2013 0b00 (0) PF \u2013 0xE8 (232), SW ID, Proprietary A PDU1 Format PS \u2013 0x22 (34), i.e. example destination address? SrcAddr \u2013 0xF2 (242), i.e. Touch Encoder source address ID \u2013 0x18E822F2 Direction \u2013 Transmit Data Length \u2013 8 bytes Priority \u2013 6 Transmission Rate \u2013 Upon appropriate response Start Length Desc. Values 1 1 Byte Control Byte 0 = Positive Acknowledgement 1 = Negative Acknowledgement 2 = Access Denied 3 = Cannot Respond 2 1 Byte Group Function Refer to SAE-J1939-21 3-5 3 Bytes Reserved by SAE 6-8 3 Bytes Parameter Group being Acknowledged","title":"SAE J1939"},{"location":"comm_protocols/sae_j1939/#sae-j1939-documentation","text":"","title":"SAE J1939 Documentation"},{"location":"comm_protocols/sae_j1939/#1-overview","text":"This document describes the functionality and communication of the Grayhill Touch Encoder product.","title":"1. Overview"},{"location":"comm_protocols/sae_j1939/#11-reference-documents","text":"The following documents are referenced within this document. SAE-J1939 SAE-J1939/11 SAE-J1939/21 SAE-J1939/71 SAE-J1939/81","title":"1.1 Reference Documents"},{"location":"comm_protocols/sae_j1939/#2-j1939-communications","text":"","title":"2. J1939 Communications"},{"location":"comm_protocols/sae_j1939/#21-message-header-description","text":"The figure below illustrates the format of the CAN message ID. A brief description of each field follows.","title":"2.1 Message Header Description"},{"location":"comm_protocols/sae_j1939/#211-priority","text":"This 3-bit field is used to define the priority during arbitration. 0 is the highest priority and is usually associated with high-speed control messages. Low priority is used for non-critical configuration and information messages. The lowest priority value is 7.","title":"2.1.1 Priority"},{"location":"comm_protocols/sae_j1939/#212-data-page-dp","text":"This 1-bit field defines on which data page (0 or 1) the message is defined in the J1939 specification. Page 0 contains the messages that are presently defined, while Page 1 is for future expansion according to J1939.","title":"2.1.2 Data Page (DP)"},{"location":"comm_protocols/sae_j1939/#213-protocol-data-unit-pdu-pdu-format-pf","text":"This 8-bit field determines the format of the message and is one of the fields which determine the Parameter Group Number of the message (see 2.1.6). If the value is between 0 and 239, the message is a PDU 1 format message. These messages are sent to specific addresses. If the value is between 240 and 255, the message is a PDU 2 format message. These messages are not sent to a specific address, but are instead broadcast to the entire network.","title":"2.1.3 Protocol Data Unit (PDU) - PDU Format (PF)"},{"location":"comm_protocols/sae_j1939/#214-protocol-data-unit-pdu-pdu-specific-ps","text":"The PDU Specific (PS) field is the Destination Address (DA) in a PDU 1 Format. In a PDU 2 format the PS becomes the Group Extension (GE). This field is 8 bits long.","title":"2.1.4 Protocol Data Unit (PDU) - PDU Specific (PS)"},{"location":"comm_protocols/sae_j1939/#215-source-address","text":"This 8-bit field is the source address of the device that sent the message.","title":"2.1.5 Source Address"},{"location":"comm_protocols/sae_j1939/#216-parameter-group-number","text":"J1939 defines allowable messages by their Parameter Group Number (PGN). The Parameter Group Number is an 18-bit value that uniquely defines the message purpose. It is composed of the Reserved bit, DP, PF and PS, all of which are described above.","title":"2.1.6 Parameter Group Number"},{"location":"comm_protocols/sae_j1939/#22-j1939-bit-field-location-and-byte-ordering","text":"The first data byte is sent first and is referenced as Byte 1. The LSB of the data bytes are on the right and are referenced as Bit 1. All multibyte data fields are specified in little-endian byte order unless stated otherwise. The convention used to locate a parameter in the data field is the same as specified in SAE-J1939/71. The format used is \"R.x\" where R is the byte number and x is the starting bit number within the byte. The length is the number of bits starting at this point. Example : Location 4.3 with a length of 3 bits would have the value of 1 as illustrated below. Byte 4 = 0x67 = 0b011 001 11. The bold value is the three bit field holding a value of 0b001. Example : Location 4.3 with a length of 3 bits would have the value of 6 as illustrated below. Byte 4 = 0x7b = 0b011 110 11. The bold value is the three bit field holding a value of 0b110.","title":"2.2 J1939 Bit Field Location and Byte Ordering"},{"location":"comm_protocols/sae_j1939/#23-grayhill-touch-encoder-source-address","text":"The source address of the Grayhill Touch Encoder device is set to 242 (0xF2) at the factory. This may be modified dynamically with the proprietary Source Address Command. The source address value is stored in non-volatile memory. Touch Encoder assumes this value at startup but the actual source address is the result of Dynamic Adressing. Multiple Touch Encoder devices can coexist in the same system.","title":"2.3 Grayhill Touch Encoder Source Address"},{"location":"comm_protocols/sae_j1939/#24-standard-messages","text":"The Events Data message and the Widget Data message all use the Proprietary B PDU2 format (PF = 255) that broadcasts to no specific address the status of the device. The Control Data message uses Proprietary A PDU1 format (PF = 239).","title":"2.4 Standard Messages"},{"location":"comm_protocols/sae_j1939/#241-events-data-message","text":"Priority \u2013 0b110 (6) R/DP \u2013 0b00 (0) PF \u2013 0xFF (255), Proprietary B PDU2 Format GrpExt \u2013 0x0F (15) SrcAddr \u2013 0xF2 (242), i.e. Touch Encoder default source address ID \u2013 0x18FF0FF2 Direction \u2013 Transmit Data Length \u2013 8 bytes Transmission Rate \u2013 On Event (programmable) * The Events Data PGN can be reassigned using a configuration command. Start Length Desc. Values 1.1 8 bits Screen Number 0x01 \u2013 Screen #1 at the time of event \u2026 0xFF \u2013 Screen #255 at the time of event 2.1 8 bits Reserved Reserved for future use 3.1 8 bits Event ID 0x01- Events: Standard (Relative Encoder, Taps, Swipes) 4.1 8 bits Encoder (relative) 0x80 \u2013 No Change 0x81 \u2013 Clockwise 1 detent 0x82 \u2013 Clockwise 2 detents \u2026 0xFE \u2013 Clockwise 126 detents 0x7F \u2013 Counter-Clockwise 1 detent 0x7E \u2013 Counter-Clockwise 2 detents \u2026 0x01 \u2013 Counter-Clockwise 127 detents 0x00 \u2013 Not used 0xFF \u2013 Not used 5.1 16 bits Tap Mask* 0x0000 \u2013 No Tap detected 0x0001 \u2013 Tap in Zone 1 detected 0x0002 \u2013 Tap in Zone 2 detected 0x0004 \u2013 Tap in Zone 3 detected \u2026 0x4000 \u2013 Tap in Zone 15 detected 0x8000 \u2013 Tap on screen (anywhere) detected 7.1 8 bits Swipe Mask 0x00 \u2013 No Swipe detected 0x01 \u2013 Swipe Up detected 0x02 \u2013 Swipe Down detected 0x03 \u2013 Swipe Left detected 0x04 \u2013 Swipe Right detected 0x80 \u2013 Swipe (any direction) detected * This field is specified in big-endian byte order. The Events Data message is sent to inform the receiving (host) ECU of any new encoder, tap or swipe events that occurred on the Touch Encoder device. If such an event causes a new screen to be displayed or if any of the Value IDs on the current screen were changed, the event is followed by a Widget Data message or messages which, on a screen change, will communicate the data in all Value IDs on the new screen. Example : Turning the encoder counter-clockwise by 2 detents on screen 1 (since last message) will result in the following message being transmitted. ID=0x18FF0FF2, LEN=8, DATA=0x01,0x00,0x01,0x7E,0x00,0x00,0x00,0xFF Example : Swiping up on the touch pad on screen 5 will result in the following message being transmitted. ID=0x18FF0FF2, LEN=8, DATA=0x05,0x00,0x01,0x80,0x00,0x00,0x81,0xFF Example : Tapping in screen 10 zone 4 of the touch pad will result in the following message being transmitted. ID=0x18FF0FF2, LEN=8, DATA=0x0A,0x00,0x01,0x80,0x80,0x08,0x00,0xFF","title":"2.4.1 Events Data Message"},{"location":"comm_protocols/sae_j1939/#242-widget-data-message","text":"Priority \u2013 0b110 (6) R/DP \u2013 0b00 (0) PF \u2013 0xFF (255), Proprietary B PDU2 Format GrpExt \u2013 0x11 (17) SrcAddr \u2013 0xF2 (242), i.e. Touch Encoder default source address ID \u2013 0x18FF11F2 Direction \u2013 Transmit Data Length \u2013 8 bytes Transmission Rate \u2013 On Event (programmable) * The Widget Data PGN can be reassigned using a configuration command. As described in the previous section, if an event on the Touch Encoder Device causes a new screen to be displayed or if the event causes a change in one of the active Value IDs on the current screen, the Events Data message is immediately followed by a Widget Data message. Due to CAN restrictions on the number of data bytes allowed per CAN frame, Widget Data reports with multiple Value IDs need to split up into several messages. The number of messages needed is the number of Value IDs. For instance, for a single active Value ID, only one message is needed. For multiple active Value IDs, multiple messages are sent consecutively, each for a single Value ID. Start Length Desc. Values 1.1 8 bits Screen Number 0x01 \u2013 Screen #1 currently being displayed \u2026 0xFF \u2013 Screen #255 currently being displayed 2.1 8 bits Reserved Reserved for future use 3.1 8 bits Value ID 0x00 \u2013 No Values on this screen 0x01 \u2013 Value ID #1 0x02 \u2013 Value ID #2 0x04 \u2013 Value ID #3 \u2026 0x80 \u2013 Value ID #8 4.1 16 bits Current Value Value currently being displayed for the given Value ID 6.1 4 bits Reserved 0 6.5 4 bits Display Code Display Code (Decimal Code) for this Value 7.1 8 bits Active Value ID Bitmask 0x00 \u2013 Not used 0x01 \u2013 Value ID (Value #1 is active for this screen) 0x02 \u2013 Value ID (Value #2 is active for this screen) \u2026 0xFF \u2013 Value ID (All 8 Values active for this screen) Example : For two active Value IDs, two separate messages are needed to convey all of the Widget information. Below is an example of the messages with a widget that has two ValueIDs. The first being a temperature setting of 75 and the second being a fan speed of 5. ID=0x18FF11F2, LEN=8, DATA=0x01,0x00,0x01,0x4B,0x00,0x00,0x03,0xFF ID=0x18FF11F2, LEN=8, DATA=0x01,0x00,0x02,0x05,0x00,0x00,0x03,0xFF","title":"2.4.2 Widget Data Message"},{"location":"comm_protocols/sae_j1939/#243-configuration-and-control-message","text":"Priority \u2013 0b110 (6) R/DP \u2013 0b00 (0) PF \u2013 0xEF (239) Proprietary A PDU1 Format PS \u2013 DestAddr, i.e. address of the Touch Encoder device, default value: 242 (0xF2) SrcAddr \u2013 0x21 (33), i.e. example source address ID \u2013 0x18EFF221 Direction \u2013 Receive Data Length \u2013 8 Start Length Desc. Values 1.1 1 Byte Configuration and Control Command Command Byte as described in sec. 3 2.1 7 Bytes Configuration and Control Data Variable as described in sec. 3","title":"2.4.3 Configuration and Control Message"},{"location":"comm_protocols/sae_j1939/#3-configuration-and-control-commands","text":"Changing of the configuration and how the Touch Encoder device behaves is done with the Configuration and Control message described in section 2.4.3. The first byte serves as the command byte. Where applicable, changes take effect immediately and are stored in non-volatile memory unless otherwise noted. The header information for these commands is as follows: Priority \u2013 0b110 (6) R/DP \u2013 0b00 (0) PF \u2013 0xEF (239) PS \u2013 DestAddr, i.e. address of the Touch Encoder device, default value: 0xF2 (242) SrcAddr \u2013 0x21 (33), i.e. example source address ID \u2013 0x18EFF221, Proprietary A PDU1 Format Direction \u2013 Receive","title":"3. Configuration and Control Commands"},{"location":"comm_protocols/sae_j1939/#31-modify-widget-data","text":"Data Length \u2013 7 bytes Start Length Desc. Values 1.1 8 bits Command 0x11 \u2013 Force Widget Data 2.1 8 bits Screen Number 0x00 \u2013 Screen #0 to be displayed 0x01 \u2013 Screen #1 to be displayed \u2026 0xFF \u2013 Screen #255 to be displayed 3.1 8 bits Value ID 0x00 \u2013 No altered Values 0x01 \u2013 Value ID #1 0x02 \u2013 Value ID #2 0x04 \u2013 Value ID #3 \u2026 0x80 \u2013 ValueID #8 4.1 16 bits Current Value Value to be displayed. This value is of the format specified by Display Code value 6.1 1 bit Screen Transition Suppressor 0 \u2013 Perform screen transition 1 \u2013 Suppress screen transition 6.2 3 bits Reserved 0 6.5 4 bits Display Code Display Code for this Value (Decimal Code) 7.1 8 bits Active Value ID Bitmask 0x00 \u2013 Not used 0x01 \u2013 Value #1 currently active 0x02 \u2013 Value #2 currently active \u2026 0x80 \u2013 All 8 Values currently active Example : Sending the following message to a Touch Encoder device having the default address of 0xF2 will set the current screen to be displayed to 0x03 and the current value of ValueID #2 of that screen to 0x01F4. ID=18EFF221, LEN=8, Data=0x11, 0x03, 0x02, 0xF4, 0x01, 0x00, 0x02, 0xFF","title":"3.1 Modify Widget Data"},{"location":"comm_protocols/sae_j1939/#311-multi-value-data-example","text":"Example : The figure above displays an example of a multi-value widget. The dynamic text object is designated at Value ID #2. The lighted icon object is designated as Value ID #3. Below is the sequence of messages to turn on the top lighted icon and change the dynamic text to 100. ID=18EFF221, LEN=8, Data=0x11, 0x03, 0x04, 0x01, 0x00, 0x00, 0x06, 0xFF ID=18EFF221, LEN=8, Data=0x11, 0x03, 0x02, 0x64, 0x00, 0x00, 0x06, 0xFF","title":"3.1.1 Multi-Value Data Example"},{"location":"comm_protocols/sae_j1939/#312-display-code","text":"The Display Code gives the Touch Encoder the ability to display decimal numbers. The Display Code occupies 4 upper bits of byte 6. The value of this field is interpreted as a signed 4-bit integer that specifies the direction and the amount of decimal places to shift the point by. The alternative name for this field is Decimal Code. The table below describes how the decimal code works. Decimal Code Value Display Value Description 0x0 1 1 Display value directly 0x1 1 10 value x 10 (shift right one place) 0x2 1 100 value x 100 (shift right two places) 0xE 1 0.01 value \u00f7 100 (shift left two places) 0xF 1 0.1 value \u00f7 10 (shift left one place)","title":"3.1.2 Display Code"},{"location":"comm_protocols/sae_j1939/#313-screen-transition-suppression","text":"The Screen Transition Suppressor (STS) enables the Touch Encoder to modify variable data of the target screen without first transitioning to that screen. If the corresponding bit is set, the Touch Encoder will not perform a screen transition prior to applying a data change. This feature is available in Touch Encoder firmware version 3.1.0 or higher.","title":"3.1.3 Screen Transition Suppression"},{"location":"comm_protocols/sae_j1939/#32-modify-events-data-pgn","text":"Data Length \u2013 8 bytes Byte 1 Byte 2 Byte 3 Byte 4 Byte 5 Byte 6 Byte 7 Byte 8 0xD1 aa bb xx xx xx 0x55 0xAA aa \u2013 The least significant byte of the new PGN. Valid Range: 0..255 bb - The most significant byte of the new PGN. Valid Range: 0..255 xx \u2013 Don't Care. Should be 0xFF following J1939 convention 0x55 \u2013 Low byte of 16 bit key 0xAA \u2013 High byte of 16 bit key","title":"3.2 Modify Events Data PGN"},{"location":"comm_protocols/sae_j1939/#33-modify-events-data-transmission-period","text":"Data Length \u2013 8 bytes Byte 1 Byte 2 Byte 3 Byte 4 Byte 5 Byte 6 Byte 7 Byte 8 0xD3 dd Event xx xx xx 0x55 0xAA dd \u2013 specifies transmission period. Valid range is 0..255. The actual period is determined by multiplying the value by 10ms. This yields the minimum of 10ms and the maximum of 2.55 seconds. The value of 0 turns off periodic transmission of the message. Event \u2013 transmit on event. Valid values are 0 and 1. The value of 1 sends the message upon state change. The value of 0 will cause the message to be transmitted only at the specified time interval unless also set to 0. xx \u2013 Don't Care. Should be 0xFF following J1939 convention 0x55 \u2013 Low byte of 16 bit key 0xAA \u2013 High byte of 16 bit key","title":"3.3 Modify Events Data Transmission Period"},{"location":"comm_protocols/sae_j1939/#34-modify-widgets-data-pgn","text":"Data Length \u2013 8 bytes Byte 1 Byte 2 Byte 3 Byte 4 Byte 5 Byte 6 Byte 7 Byte 8 0xD9 aa bb xx xx xx 0x55 0xAA aa \u2013 The least significant byte of the new PGN. Valid Range: 0..255 bb - The most significant byte of the new PGN. Valid Range: 0..255 xx \u2013 Don't Care. Should be 0xFF following J1939 convention 0x55 \u2013 Low byte of 16 bit key 0xAA \u2013 High byte of 16 bit key","title":"3.4 Modify Widgets Data PGN"},{"location":"comm_protocols/sae_j1939/#35-modify-widgets-data-transmission-period","text":"Data Length \u2013 8 bytes Byte 1 Byte 2 Byte 3 Byte 4 Byte 5 Byte 6 Byte 7 Byte 8 0xDB dd Event xx xx xx 0x55 0xAA dd \u2013 specifies transmission period. Valid range is 0..255. The actual period is determined by multiplying the value by 10ms. This yields the minimum of 10ms and the maximum of 2.55 seconds. The value of 0 turns off periodic transmission of the message. Event \u2013 transmit on event. Valid values are 0 and 1. The value of 1 sends the message upon state change. The value of 0 will cause the message to be transmitted only at the specified time interval unless also set to 0. xx \u2013 Don't Care. Should be 0xFF following J1939 convention 0x55 \u2013 Low byte of 16 bit key 0xAA \u2013 High byte of 16 bit key","title":"3.5 Modify Widgets Data Transmission Period"},{"location":"comm_protocols/sae_j1939/#36-modify-message-priority","text":"Data Length \u2013 8 bytes Byte 1 Byte 2 Byte 3 Byte 4 Byte 5 Byte 6 Byte 7 Byte 8 0xD2 dd xx xx xx xx 0x55 0xAA dd \u2013 The new priority. Valid Range: 0..7 xx \u2013 Don't Care. Should be 0xFF following J1939 convention 0x55 \u2013 Low byte of 16 bit key 0xAA \u2013 High byte of 16 bit key Applies to all messages sent by the Touch Encoder.","title":"3.6 Modify Message Priority"},{"location":"comm_protocols/sae_j1939/#37-modify-source-address","text":"Data Length \u2013 8 bytes Byte 1 Byte 2 Byte 3 Byte 4 Byte 5 Byte 6 Byte 7 Byte 8 0xE0 dd xx xx xx xx 0x55 0xAA dd \u2013 Has a value between 128 and 245 and is the new source address xx \u2013 Don't Care. Should be 0xFF following J1939 convention 0x55 \u2013 Low byte of 16 bit key 0xAA \u2013 High byte of 16 bit key","title":"3.7 Modify Source Address"},{"location":"comm_protocols/sae_j1939/#38-backlight-intensity","text":"Data Length \u2013 8 bytes Byte 1 Byte 2 Byte 3 Byte 4 Byte 5 Byte 6 Byte 7 Byte 8 0x80 xx dd xx xx xx xx xx dd \u2013 Has a value between 0 and 100 and is the percentage of backlight intensity xx \u2013 Don't Care. Should be 0xFF following J1939 convention","title":"3.8 Backlight Intensity"},{"location":"comm_protocols/sae_j1939/#39-live-update-request","text":"Data Length \u2013 8 bytes Start Length Desc. Values 1.1 1 Byte Command 0x55 - Live Update Request 2.1 1 Byte Component type 0 - package 3 - project 3.1 3 Bytes Upload Size File size in bytes 6.1 3 Bytes PGN PGN value to use for the update session Example : The following message requests the update of Touch Encoder project. The origin (0x21) obligates itself to upload a file of size equal to 2212495 bytes (roughly 2.11MB) over PGN 0x13300. The file, once succesfully submitted, will be used to update the TE project. ID=18EFF221, LEN=8, Data=0x55, 0x03, 0x8F, 0xC2, 0x21, 0x00, 0x33, 0x01 To learn more about the live update procedure, see our Live Update guide .","title":"3.9 Live Update Request"},{"location":"comm_protocols/sae_j1939/#4-other-j1939-messages","text":"The following messages are defined in the J1939 documents and are implemented in the Touch Encoder device.","title":"4. Other J1939 Messages"},{"location":"comm_protocols/sae_j1939/#41-address-claimed","text":"Priority \u2013 0b110 (6) R/DP \u2013 0b00 (0) PF \u2013 0xEE (238), Address Claimed PS \u2013 DestAddr, address should always be the Global Address, 0xFF SrcAddr \u2013 0xF2 (242), i.e. Touch Encoder source address ID \u2013 0x18EEFFF2, Proprietary A PDU1 Format Direction \u2013 Transmit Data Length \u2013 8 bytes Transmission Rate \u2013 Upon boot or whenever requested Start Length Desc. Values 1.1 21 Bits Identity Number Device-unique value 3.6 11 Bits Manufacturers Code 294 (Assigned to Grayhill by SAE) 5.1 3 Bits ECU Instance 0 (Default) 5.4 5 Bits Function Instance 0 (Default) 6.1 8 Bits Function 60 (Cab Display) * 7.1 1 Bit Reserved 0 (Defined by SAE) 7.2 7 Bits Vehicle System 0 (Default) 8.1 4 Bits Vehicle System Instance 0 (Default) 8.5 3 Bits Industry Group 0 Global (Default) 8.8 1 Bit Arbitrary Address Capable 1 Capable (Default) *Refer to J1939 base document for the Function value based on the Industry Group and Vehicle System combinations","title":"4.1 Address Claimed"},{"location":"comm_protocols/sae_j1939/#42-pgn-request","text":"Priority \u2013 0b110 (6) R/DP \u2013 0b00 (0) PF \u2013 0xEA (234), PGN Request, Proprietary A PDU1 Format PS \u2013 DestAddr, address of the Touch Encoder device to respond or the Global Address SrcAddr \u2013 0x21 (33), i.e. example source address ID \u2013 0x18EAF221 Direction \u2013 Receive Data Length \u2013 3 Start Length Desc. Values 1 1 Byte Byte 1 of PGN being requested (LSB) 0 to 255 2 1 Byte Byte 2 of PGN being requested 0 to 255 3 1 Byte Byte 3 of PGN being requested (MSB) 0 The following are the supported PGN's that can be requested from the keypad. If the request is unsupported the keypad responds with a NACK (Refer to J1939-21).","title":"4.2 PGN Request"},{"location":"comm_protocols/sae_j1939/#421-ecu-identification-information-coming-soon","text":"Priority \u2013 0b110 (6) R/DP \u2013 0b00 (0) PF \u2013 0xFD (253), ECU ID, Proprietary B PDU2 Format PS \u2013 0xC5 (197)? SrcAddr \u2013 0xF2 (242), i.e. Touch Encoder source address ID \u2013 0x18FDC5F2 Direction \u2013 Transmit Data Length \u2013 Variable Transmission Rate \u2013 Upon Request Multi Packet Transerred \u2013 Yes, BAM only Start Length Desc. Values * 1 <=64 ECU Part Number Ex. \"3KYY1001-1\" Variable <=64 ECU Serial Number Ex. \"123456\" Variable <=64 ECU Location Ex. \"CAB\" Variable <=64 ECU Type Ex. \"KEYPAD\" *All fields \"*\" ASCII delimited","title":"4.2.1 ECU Identification Information (COMING SOON)"},{"location":"comm_protocols/sae_j1939/#422-software-identification","text":"Priority \u2013 0b110 (6) R/DP \u2013 0b00 (0) PF \u2013 0xFE (254), SW ID, Proprietary B PDU2 Format PS \u2013 0xDA (218) SrcAddr \u2013 0xF2 (242), i.e. Touch Encoder source address ID \u2013 0x18FEDAF2 Direction \u2013 Transmit Data Length \u2013 Variable, 13-67 bytes Transmission Rate \u2013 Upon Request Multi Packet Transferred \u2013 Yes, BAM only Start Length Desc. Values 1 1 Byte Number of software fields 2 2 5-N Bytes Firmware version # (Major.Minor.Patch) (ASCII) Ex. 4.3.1 Variable 5-N Bytes Bootloader version # (Major.Minor.Patch) (ASCII) Ex. 7.5.3 *All fields \"*\" ASCII delimited","title":"4.2.2 Software Identification"},{"location":"comm_protocols/sae_j1939/#43-acknowledgement-message","text":"Priority \u2013 0b110 (6) R/DP \u2013 0b00 (0) PF \u2013 0xE8 (232), SW ID, Proprietary A PDU1 Format PS \u2013 0x22 (34), i.e. example destination address? SrcAddr \u2013 0xF2 (242), i.e. Touch Encoder source address ID \u2013 0x18E822F2 Direction \u2013 Transmit Data Length \u2013 8 bytes Priority \u2013 6 Transmission Rate \u2013 Upon appropriate response Start Length Desc. Values 1 1 Byte Control Byte 0 = Positive Acknowledgement 1 = Negative Acknowledgement 2 = Access Denied 3 = Cannot Respond 2 1 Byte Group Function Refer to SAE-J1939-21 3-5 3 Bytes Reserved by SAE 6-8 3 Bytes Parameter Group being Acknowledged","title":"4.3 Acknowledgement Message"}]}